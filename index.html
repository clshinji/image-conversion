<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”»åƒå¤‰æ›ãã‚“ - ã‹ã‚“ãŸã‚“ç”»åƒãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå¤‰æ›</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1 style="display: flex !important; align-items: center !important; justify-content: center !important; gap: 12px !important;"><img src="favicon.png" alt="ç”»åƒå¤‰æ›ãã‚“" class="app-icon" style="width: 48px !important; height: 48px !important; display: inline-block !important; vertical-align: middle !important; margin-right: 8px !important; border-radius: 8px !important; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;"> ç”»åƒå¤‰æ›ãã‚“</h1>
            <p>ã©ã‚“ãªç”»åƒã§ã‚‚ãƒ‘ãƒ‘ãƒƒã¨å¤‰æ›ï¼SVGã€PNGã€JPGã€WebPã€GIFã«å¯¾å¿œã ã‚ˆã€œ</p>
        </header>

        <main>
            <!-- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ -->
            <section class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-content">
                        <div class="upload-icon">ğŸ“</div>
                        <p>ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã“ã“ã«ãƒã‚¤ãƒƒã¨æŠ•ã’è¾¼ã‚€ã‹ã€ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸ã‚“ã§ã­ï¼<br>
                        <small>ï¼ˆSVGã€PNGã€JPGã€WebPã€GIFå¯¾å¿œã ã‚ˆã€œï¼‰</small></p>
                        <input type="file" id="fileInput" accept=".svg,.png,.jpg,.jpeg,.webp,.gif,image/svg+xml,image/png,image/jpeg,image/webp,image/gif" multiple hidden>
                        <button type="button" class="upload-btn" id="uploadBtn">ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã¶ã‚ˆã€œ</button>
                    </div>
                </div>
            </section>

            <!-- ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
            <section class="file-info" id="fileInfo" style="display: none;">
                <h3>ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±</h3>
                <div class="info-content">
                    <p><strong>ãƒ•ã‚¡ã‚¤ãƒ«å:</strong> <span id="fileName"></span></p>
                    <p><strong>ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º:</strong> <span id="fileSize"></span></p>
                </div>
            </section>

            <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ -->
            <section class="preview-section">
                <div class="preview-container">
                    <!-- å…ƒç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
                    <div class="preview-box" id="originalPreview" style="display: none;">
                        <h3 id="originalPreviewTitle">å…ƒç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
                        <div class="preview-content" id="originalPreviewContent"></div>
                    </div>

                    <!-- å¤‰æ›å¾Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
                    <div class="preview-box" id="convertedPreview" style="display: none;">
                        <h3 id="convertedPreviewTitle">å¤‰æ›å¾Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
                        <div class="preview-content" id="convertedPreviewContent"></div>
                    </div>
                </div>
            </section>

            <!-- å¤‰æ›ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚¨ãƒªã‚¢ -->
            <section class="conversion-options" id="conversionOptions" style="display: none;">
                <h3>å¤‰æ›ã‚ªãƒ—ã‚·ãƒ§ãƒ³</h3>
                <div class="options-content">
                    <!-- å¤‰æ›å…ˆå½¢å¼é¸æŠ -->
                    <div class="option-group">
                        <label class="option-label-text">å¤‰æ›å…ˆå½¢å¼</label>
                        <div class="format-selection">
                            <select id="targetFormat" class="format-dropdown">
                                <option value="png">PNG</option>
                                <option value="jpg">JPG</option>
                                <option value="webp">WebP</option>
                                <option value="gif">GIF</option>
                                <option value="svg">SVG</option>
                            </select>
                        </div>
                        <p class="option-description">å¤‰æ›å¾Œã®ç”»åƒå½¢å¼ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
                    </div>
                    
                    <!-- å‡ºåŠ›ã‚µã‚¤ã‚ºé¸æŠ -->
                    <div class="option-group" id="sizeGroup">
                        <label class="option-label-text">å‡ºåŠ›ã‚µã‚¤ã‚º</label>
                        <div class="size-selection">
                            <select id="sizePreset" class="size-dropdown">
                                <option value="original">å…ƒã®ã‚µã‚¤ã‚º</option>
                                <option value="100x100">100 Ã— 100 (ã‚¢ã‚¤ã‚³ãƒ³)</option>
                                <option value="200x200">200 Ã— 200 (å°)</option>
                                <option value="500x500">500 Ã— 500 (ä¸­)</option>
                                <option value="1000x1000">1000 Ã— 1000 (å¤§)</option>
                                <option value="1920x1080">1920 Ã— 1080 (ãƒ•ãƒ«HD)</option>
                                <option value="custom">ã‚«ã‚¹ã‚¿ãƒ ã‚µã‚¤ã‚º</option>
                            </select>
                        </div>
                        
                        <!-- ã‚«ã‚¹ã‚¿ãƒ ã‚µã‚¤ã‚ºå…¥åŠ› -->
                        <div class="custom-size-inputs" id="customSizeInputs" style="display: none;">
                            <div class="size-input-row" style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                                <div class="size-input-group">
                                    <label for="customWidth">å¹… (px)</label>
                                    <input type="number" id="customWidth" min="1" max="10000" placeholder="å¹…" style="width: 80px;">
                                </div>
                                <div class="size-connector">Ã—</div>
                                <div class="size-input-group">
                                    <label for="customHeight">é«˜ã• (px)</label>
                                    <input type="number" id="customHeight" min="1" max="10000" placeholder="é«˜ã•" style="width: 80px;">
                                </div>
                            </div>
                            <div style="margin-top: 10px;">
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="checkbox" id="maintainAspectRatio" checked>
                                    <span>ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ</span>
                                </label>
                            </div>
                        </div>
                        
                        <p class="option-description">å¤‰æ›å¾Œã®ç”»åƒã‚µã‚¤ã‚ºã‚’é¸æŠã—ã¦ãã ã•ã„ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã¯è‡ªå‹•çš„ã«ç¶­æŒã•ã‚Œã¾ã™ï¼‰</p>
                    </div>
                    
                    <!-- å“è³ªè¨­å®š -->
                    <div class="option-group" id="qualityGroup" style="display: none;">
                        <label class="option-label-text">å“è³ªè¨­å®š</label>
                        <div class="quality-selection">
                            <div class="quality-slider-container">
                                <input type="range" id="qualitySlider" min="10" max="100" value="90" class="quality-slider">
                                <div class="quality-value-container">
                                    <span id="qualityValue" class="quality-value">90%</span>
                                </div>
                            </div>
                        </div>
                        <p class="option-description">JPGãƒ»WebPå½¢å¼ã®åœ§ç¸®å“è³ªã‚’è¨­å®šã—ã¾ã™</p>
                    </div>

                    <!-- èƒŒæ™¯è‰²è¨­å®š -->
                    <div class="option-group" id="backgroundGroup">
                        <label class="option-label-text">èƒŒæ™¯è¨­å®š</label>
                        
                        <!-- é€æ˜åº¦ã‚ªãƒ—ã‚·ãƒ§ãƒ³ -->
                        <div class="transparency-options">
                            <label class="option-label">
                                <input type="checkbox" id="transparentBgOption" checked>
                                <span class="checkmark"></span>
                                <span class="option-text">é€æ˜èƒŒæ™¯ã‚’ç¶­æŒ</span>
                            </label>
                        </div>
                        
                        <!-- èƒŒæ™¯è‰²è¨­å®š -->
                        <div class="background-color-group" id="backgroundColorGroup" style="display: none;">
                            <div class="color-selection-header">
                                <label for="backgroundColor" class="color-label">èƒŒæ™¯è‰²</label>
                            </div>
                            
                            <div class="color-picker-container">
                                <input type="color" id="backgroundColor" value="#ffffff" class="color-picker">
                            </div>
                        </div>
                        
                        <p class="option-description" id="backgroundDescription">
                            é€æ˜åº¦ã‚’ã‚µãƒãƒ¼ãƒˆã—ãªã„å½¢å¼ï¼ˆJPEGï¼‰ã§ã¯èƒŒæ™¯è‰²ãŒé©ç”¨ã•ã‚Œã¾ã™
                        </p>
                    </div>
                </div>
            </section>

            <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ -->
            <section class="controls">
                <div class="single-file-controls" id="singleFileControls">
                    <button type="button" class="btn btn-primary" id="convertBtn" disabled>å¤‰æ›å®Ÿè¡Œ</button>
                    <button type="button" class="btn btn-success" id="downloadBtn" disabled>ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                </div>
            </section>

            <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¨ãƒªã‚¢ -->
            <section class="message-area">
                <div class="error-message" id="errorMessage" style="display: none;"></div>
                <div class="success-message" id="successMessage" style="display: none;"></div>
            </section>
        </main>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let currentFile = null;
        let convertedBlob = null;
        
        // DOMè¦ç´ ã®å–å¾—
        const elements = {
            uploadArea: document.getElementById('uploadArea'),
            fileInput: document.getElementById('fileInput'),
            uploadBtn: document.getElementById('uploadBtn'),
            fileInfo: document.getElementById('fileInfo'),
            fileName: document.getElementById('fileName'),
            fileSize: document.getElementById('fileSize'),
            originalPreview: document.getElementById('originalPreview'),
            originalPreviewContent: document.getElementById('originalPreviewContent'),
            convertedPreview: document.getElementById('convertedPreview'),
            convertedPreviewContent: document.getElementById('convertedPreviewContent'),
            convertBtn: document.getElementById('convertBtn'),
            downloadBtn: document.getElementById('downloadBtn'),
            errorMessage: document.getElementById('errorMessage'),
            successMessage: document.getElementById('successMessage'),
            conversionOptions: document.getElementById('conversionOptions'),
            targetFormat: document.getElementById('targetFormat'),
            qualityGroup: document.getElementById('qualityGroup'),
            qualitySlider: document.getElementById('qualitySlider'),
            qualityValue: document.getElementById('qualityValue'),
            transparentBgOption: document.getElementById('transparentBgOption'),
            backgroundColor: document.getElementById('backgroundColor'),
            backgroundColorGroup: document.getElementById('backgroundColorGroup'),
            sizeGroup: document.getElementById('sizeGroup'),
            sizePreset: document.getElementById('sizePreset'),
            customSizeInputs: document.getElementById('customSizeInputs'),
            customWidth: document.getElementById('customWidth'),
            customHeight: document.getElementById('customHeight'),
            maintainAspectRatio: document.getElementById('maintainAspectRatio')
        };
        
        // åˆæœŸåŒ–
        function init() {
            console.log('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åˆæœŸåŒ–ä¸­...');
            setupEventListeners();
            console.log('åˆæœŸåŒ–å®Œäº†');
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        function setupEventListeners() {
            // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒœã‚¿ãƒ³
            elements.uploadBtn?.addEventListener('click', () => {
                console.log('ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
                elements.fileInput?.click();
            });
            
            // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ã®ã‚¯ãƒªãƒƒã‚¯
            elements.uploadArea?.addEventListener('click', (event) => {
                if (event.target !== elements.uploadBtn) {
                    console.log('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
                    elements.fileInput?.click();
                }
            });
            
            // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã®å¤‰æ›´
            elements.fileInput?.addEventListener('change', (event) => {
                console.log('ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸ');
                const files = event.target.files;
                if (files.length > 0) {
                    handleFileSelection(files[0]);
                }
            });
            
            // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
            elements.uploadArea?.addEventListener('dragover', (event) => {
                event.preventDefault();
                elements.uploadArea.classList.add('dragover');
            });
            
            elements.uploadArea?.addEventListener('dragleave', (event) => {
                event.preventDefault();
                if (!elements.uploadArea.contains(event.relatedTarget)) {
                    elements.uploadArea.classList.remove('dragover');
                }
            });
            
            elements.uploadArea?.addEventListener('drop', (event) => {
                event.preventDefault();
                elements.uploadArea.classList.remove('dragover');
                console.log('ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸ');
                
                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    handleFileSelection(files[0]);
                }
            });
            
            // å¤‰æ›å…ˆå½¢å¼ã®å¤‰æ›´
            elements.targetFormat?.addEventListener('change', (event) => {
                const format = event.target.value;
                updateFormatOptions(format);
            });
            
            // å“è³ªã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å¤‰æ›´
            elements.qualitySlider?.addEventListener('input', (event) => {
                const quality = event.target.value;
                if (elements.qualityValue) {
                    elements.qualityValue.textContent = quality + '%';
                }
            });
            
            // é€æ˜èƒŒæ™¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å¤‰æ›´
            elements.transparentBgOption?.addEventListener('change', (event) => {
                const transparent = event.target.checked;
                updateBackgroundColorVisibility(transparent);
            });
            
            // ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆã®å¤‰æ›´
            elements.sizePreset?.addEventListener('change', (event) => {
                const preset = event.target.value;
                if (elements.customSizeInputs) {
                    elements.customSizeInputs.style.display = preset === 'custom' ? 'block' : 'none';
                }
            });
            
            // ã‚«ã‚¹ã‚¿ãƒ ã‚µã‚¤ã‚ºã®å¤‰æ›´ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒï¼‰
            elements.customWidth?.addEventListener('input', (event) => {
                if (elements.maintainAspectRatio?.checked && currentFile) {
                    updateHeightFromWidth(parseInt(event.target.value));
                }
            });
            
            elements.customHeight?.addEventListener('input', (event) => {
                if (elements.maintainAspectRatio?.checked && currentFile) {
                    updateWidthFromHeight(parseInt(event.target.value));
                }
            });
            
            // å¤‰æ›ãƒœã‚¿ãƒ³
            elements.convertBtn?.addEventListener('click', () => {
                handleConversion();
            });
            
            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
            elements.downloadBtn?.addEventListener('click', () => {
                handleDownload();
            });
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã®å‡¦ç†
        function handleFileSelection(file) {
            console.log('ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸ:', file.name, file.type, file.size);
            
            try {
                // åŸºæœ¬çš„ãªæ¤œè¨¼
                if (!file.type.startsWith('image/')) {
                    throw new Error('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                }
                
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆ10MBåˆ¶é™ï¼‰
                const maxSize = 10 * 1024 * 1024;
                if (file.size > maxSize) {
                    throw new Error('ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ï¼ˆ10MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„ï¼‰');
                }
                
                currentFile = file;
                
                // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã®è¡¨ç¤º
                if (elements.fileName) elements.fileName.textContent = file.name;
                if (elements.fileSize) elements.fileSize.textContent = formatFileSize(file.size);
                if (elements.fileInfo) elements.fileInfo.style.display = 'block';
                if (elements.conversionOptions) elements.conversionOptions.style.display = 'block';
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤º
                displayFilePreview(file);
                
                // å¤‰æ›ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
                if (elements.convertBtn) {
                    elements.convertBtn.disabled = false;
                }
                
                // å½¢å¼ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°
                updateFormatOptions(elements.targetFormat?.value || 'png');
                
                showMessage('ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ', 'success');
                
            } catch (error) {
                console.error('ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚¨ãƒ©ãƒ¼:', error);
                showMessage(error.message, 'error');
            }
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤º
        function displayFilePreview(file) {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const result = e.target.result;
                
                if (!elements.originalPreview || !elements.originalPreviewContent) return;
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†…å®¹ã‚’ã‚¯ãƒªã‚¢
                elements.originalPreviewContent.innerHTML = '';
                
                if (file.type.startsWith('image/svg')) {
                    // SVGãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                    const svgContainer = document.createElement('div');
                    svgContainer.innerHTML = result;
                    svgContainer.style.cssText = `
                        max-width: 100%;
                        max-height: 300px;
                        overflow: hidden;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        background: #f9f9f9;
                    `;
                    
                    const svgElement = svgContainer.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.cssText = `
                            max-width: 100%;
                            max-height: 100%;
                            width: auto;
                            height: auto;
                        `;
                    }
                    
                    elements.originalPreviewContent.appendChild(svgContainer);
                } else {
                    // ãã®ä»–ã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                    const img = document.createElement('img');
                    img.src = result;
                    img.style.cssText = `
                        max-width: 100%;
                        max-height: 300px;
                        width: auto;
                        height: auto;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                    `;
                    
                    img.onerror = () => {
                        elements.originalPreviewContent.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #666; border: 1px solid #ddd; border-radius: 4px;">
                                ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã§ãã¾ã›ã‚“
                            </div>
                        `;
                    };
                    
                    elements.originalPreviewContent.appendChild(img);
                }
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ã‚’è¡¨ç¤º
                elements.originalPreview.style.display = 'block';
            };
            
            reader.onerror = () => {
                console.error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
                showMessage('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸ', 'error');
            };
            
            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦èª­ã¿è¾¼ã¿æ–¹æ³•ã‚’å¤‰æ›´
            if (file.type.startsWith('image/svg')) {
                reader.readAsText(file);
            } else {
                reader.readAsDataURL(file);
            }
        }
        
        // å½¢å¼ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ›´æ–°
        function updateFormatOptions(format) {
            // å“è³ªè¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º
            if (elements.qualityGroup) {
                if (format === 'jpg' || format === 'jpeg' || format === 'webp') {
                    elements.qualityGroup.style.display = 'block';
                } else {
                    elements.qualityGroup.style.display = 'none';
                }
            }
            
            // ã‚µã‚¤ã‚ºè¨­å®šã®è¡¨ç¤º/éè¡¨ç¤ºï¼ˆã™ã¹ã¦ã®ç”»åƒå½¢å¼ã§åˆ©ç”¨å¯èƒ½ï¼‰
            if (elements.sizeGroup) {
                if (currentFile && format !== 'svg') {
                    elements.sizeGroup.style.display = 'block';
                } else {
                    elements.sizeGroup.style.display = 'none';
                }
            }
            
            // èƒŒæ™¯è‰²è¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º
            updateBackgroundColorVisibility(elements.transparentBgOption?.checked !== false);
        }
        
        // èƒŒæ™¯è‰²è¡¨ç¤ºã®æ›´æ–°
        function updateBackgroundColorVisibility(transparent) {
            const targetFormat = elements.targetFormat?.value || 'png';
            
            if (elements.backgroundColorGroup) {
                // JPEGã®å ´åˆã¯å¸¸ã«èƒŒæ™¯è‰²ã‚’è¡¨ç¤º
                if (targetFormat === 'jpg' || targetFormat === 'jpeg') {
                    elements.backgroundColorGroup.style.display = 'block';
                    // é€æ˜èƒŒæ™¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ç„¡åŠ¹åŒ–
                    if (elements.transparentBgOption) {
                        elements.transparentBgOption.checked = false;
                        elements.transparentBgOption.disabled = true;
                    }
                } else {
                    // ãã®ä»–ã®å½¢å¼ã§ã¯é€æ˜èƒŒæ™¯ã§ãªã„å ´åˆã®ã¿è¡¨ç¤º
                    elements.backgroundColorGroup.style.display = transparent ? 'none' : 'block';
                    // é€æ˜èƒŒæ™¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹åŒ–
                    if (elements.transparentBgOption) {
                        elements.transparentBgOption.disabled = false;
                    }
                }
            }
        }
        
        // å¤‰æ›å‡¦ç†
        async function handleConversion() {
            if (!currentFile) {
                showMessage('å¤‰æ›ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }
            
            try {
                showMessage('å¤‰æ›ä¸­...', 'info');
                if (elements.convertBtn) elements.convertBtn.disabled = true;
                
                const targetFormat = elements.targetFormat?.value || 'png';
                const quality = parseInt(elements.qualitySlider?.value || '90') / 100;
                
                convertedBlob = await convertImage(currentFile, targetFormat, quality);
                
                // å¤‰æ›å¾Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤º
                displayConvertedPreview(convertedBlob, targetFormat);
                
                if (elements.downloadBtn) elements.downloadBtn.disabled = false;
                showMessage('å¤‰æ›ãŒå®Œäº†ã—ã¾ã—ãŸ', 'success');
                
            } catch (error) {
                console.error('å¤‰æ›ã‚¨ãƒ©ãƒ¼:', error);
                showMessage(error.message, 'error');
            } finally {
                if (elements.convertBtn) elements.convertBtn.disabled = false;
            }
        }
        
        // ç”»åƒå¤‰æ›
        function convertImage(file, targetFormat, quality) {
            return new Promise((resolve, reject) => {
                // SVGå½¢å¼ã¸ã®å¤‰æ›ã®å ´åˆ
                if (targetFormat === 'svg') {
                    if (file.type.startsWith('image/svg')) {
                        // SVGã‹ã‚‰SVGã®å ´åˆã¯ãã®ã¾ã¾è¿”ã™
                        resolve(file);
                    } else {
                        // ä»–ã®å½¢å¼ã‹ã‚‰SVGã¸ã®å¤‰æ›ã¯ç¾åœ¨ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„
                        reject(new Error('SVGå½¢å¼ã¸ã®å¤‰æ›ã¯ã€SVGãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ã¿ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™'));
                    }
                    return;
                }

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    
                    img.onload = () => {
                        // ã‚µã‚¤ã‚ºã®æ±ºå®š
                        let canvasWidth, canvasHeight;
                        const sizePreset = elements.sizePreset?.value || 'original';
                        const originalWidth = img.width || 300;
                        const originalHeight = img.height || 300;
                        const aspectRatio = originalWidth / originalHeight;
                        
                        if (sizePreset === 'original') {
                            canvasWidth = originalWidth;
                            canvasHeight = originalHeight;
                        } else if (sizePreset === 'custom') {
                            const customWidth = parseInt(elements.customWidth?.value || '300');
                            const customHeight = parseInt(elements.customHeight?.value || '300');
                            
                            // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒã®ãƒã‚§ãƒƒã‚¯
                            if (elements.maintainAspectRatio?.checked) {
                                // å¹…ã‚’åŸºæº–ã«ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ
                                canvasWidth = customWidth;
                                canvasHeight = Math.round(customWidth / aspectRatio);
                            } else {
                                canvasWidth = customWidth;
                                canvasHeight = customHeight;
                            }
                        } else {
                            // ãƒ—ãƒªã‚»ãƒƒãƒˆã‚µã‚¤ã‚ºã®è§£æï¼ˆä¾‹: "500x500"ï¼‰
                            const sizeParts = sizePreset.split('x');
                            if (sizeParts.length === 2) {
                                const presetWidth = parseInt(sizeParts[0]);
                                const presetHeight = parseInt(sizeParts[1]);
                                
                                // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸã‚µã‚¤ã‚ºå†…ã«åã¾ã‚‹ã‚ˆã†ã«èª¿æ•´
                                if (aspectRatio > 1) {
                                    // æ¨ªé•·ã®å ´åˆï¼šå¹…ã‚’åŸºæº–ã«ã™ã‚‹
                                    canvasWidth = presetWidth;
                                    canvasHeight = Math.round(presetWidth / aspectRatio);
                                } else {
                                    // ç¸¦é•·ã¾ãŸã¯æ­£æ–¹å½¢ã®å ´åˆï¼šé«˜ã•ã‚’åŸºæº–ã«ã™ã‚‹
                                    canvasHeight = presetHeight;
                                    canvasWidth = Math.round(presetHeight * aspectRatio);
                                }
                            } else {
                                canvasWidth = originalWidth;
                                canvasHeight = originalHeight;
                            }
                        }
                        
                        canvas.width = canvasWidth;
                        canvas.height = canvasHeight;
                        
                        // JPGã®å ´åˆã¯èƒŒæ™¯è‰²ã‚’è¨­å®š
                        if (targetFormat === 'jpg' || targetFormat === 'jpeg') {
                            const bgColor = elements.backgroundColor?.value || '#ffffff';
                            ctx.fillStyle = bgColor;
                            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                        }
                        
                        // ç”»åƒã‚’æç”»ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¦ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
                        ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                        
                        const mimeType = getMimeType(targetFormat);
                        const canvasQuality = (targetFormat === 'jpg' || targetFormat === 'webp') ? quality : undefined;
                        
                        canvas.toBlob(resolve, mimeType, canvasQuality);
                    };
                    
                    img.onerror = () => reject(new Error('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                    
                    if (file.type.startsWith('image/svg')) {
                        // SVGã®å ´åˆã€Blobã‚’ä½œæˆã—ã¦Object URLã‚’ä½¿ç”¨
                        const svgBlob = new Blob([e.target.result], { type: 'image/svg+xml' });
                        img.src = URL.createObjectURL(svgBlob);
                    } else {
                        img.src = e.target.result;
                    }
                };
                
                reader.onerror = () => reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                
                if (file.type.startsWith('image/svg')) {
                    reader.readAsText(file);
                } else {
                    reader.readAsDataURL(file);
                }
            });
        }
        
        // MIMEã‚¿ã‚¤ãƒ—ã®å–å¾—
        function getMimeType(format) {
            const mimeTypes = {
                'png': 'image/png',
                'jpg': 'image/jpeg',
                'jpeg': 'image/jpeg',
                'webp': 'image/webp',
                'gif': 'image/gif',
                'svg': 'image/svg+xml'
            };
            return mimeTypes[format] || 'image/png';
        }
        
        // å¤‰æ›å¾Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤º
        function displayConvertedPreview(blob, format) {
            if (!elements.convertedPreview || !elements.convertedPreviewContent) return;
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†…å®¹ã‚’ã‚¯ãƒªã‚¢
            elements.convertedPreviewContent.innerHTML = '';
            
            if (format === 'svg') {
                // SVGã®å ´åˆã¯ç‰¹åˆ¥ãªå‡¦ç†
                const reader = new FileReader();
                reader.onload = (e) => {
                    const svgContainer = document.createElement('div');
                    svgContainer.innerHTML = e.target.result;
                    svgContainer.style.cssText = `
                        max-width: 100%;
                        max-height: 300px;
                        overflow: hidden;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        background: #f9f9f9;
                    `;
                    const svgElement = svgContainer.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.cssText = `
                            max-width: 100%;
                            max-height: 100%;
                            width: auto;
                            height: auto;
                        `;
                    }
                    elements.convertedPreviewContent.appendChild(svgContainer);
                };
                reader.readAsText(blob);
            } else {
                // ãã®ä»–ã®å½¢å¼ã®å ´åˆ
                const img = document.createElement('img');
                img.src = URL.createObjectURL(blob);
                img.style.cssText = `
                    max-width: 100%;
                    max-height: 300px;
                    width: auto;
                    height: auto;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                `;
                elements.convertedPreviewContent.appendChild(img);
            }
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ã‚’è¡¨ç¤º
            elements.convertedPreview.style.display = 'block';
            
            // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’è¡¨ç¤º
            const fileInfo = document.createElement('div');
            fileInfo.style.cssText = 'margin-top: 10px; font-size: 14px; color: #666;';
            fileInfo.innerHTML = `
                <div>å½¢å¼: ${format.toUpperCase()}</div>
                <div>ã‚µã‚¤ã‚º: ${formatFileSize(blob.size)}</div>
            `;
            elements.convertedPreviewContent.appendChild(fileInfo);
        }
        
        // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†
        function handleDownload() {
            if (!convertedBlob || !currentFile) {
                showMessage('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“', 'error');
                return;
            }
            
            try {
                const targetFormat = elements.targetFormat?.value || 'png';
                const originalName = currentFile.name.split('.')[0];
                const fileName = `${originalName}.${targetFormat}`;
                
                const url = URL.createObjectURL(convertedBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                
                showMessage('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹ã—ã¾ã—ãŸ', 'success');
                
            } catch (error) {
                console.error('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
                showMessage('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
            }
        }
        
        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
        function showMessage(message, type) {
            // å…¨ã¦ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’éè¡¨ç¤º
            if (elements.errorMessage) elements.errorMessage.style.display = 'none';
            if (elements.successMessage) elements.successMessage.style.display = 'none';
            
            // å¯¾å¿œã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            let messageElement;
            switch (type) {
                case 'error':
                    messageElement = elements.errorMessage;
                    break;
                case 'success':
                case 'info':
                    messageElement = elements.successMessage;
                    break;
                default:
                    messageElement = elements.successMessage;
            }
            
            if (messageElement) {
                messageElement.textContent = message;
                messageElement.style.display = 'block';
                
                // è‡ªå‹•éè¡¨ç¤ºï¼ˆã‚¨ãƒ©ãƒ¼ä»¥å¤–ï¼‰
                if (type !== 'error') {
                    setTimeout(() => {
                        messageElement.style.display = 'none';
                    }, 5000);
                }
            }
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // ç”»åƒã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’å–å¾—
        function getImageAspectRatio() {
            return new Promise((resolve) => {
                if (!currentFile) {
                    resolve(1);
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const aspectRatio = (img.width || 300) / (img.height || 300);
                        resolve(aspectRatio);
                    };
                    img.onerror = () => resolve(1);
                    
                    if (currentFile.type.startsWith('image/svg')) {
                        const svgBlob = new Blob([e.target.result], { type: 'image/svg+xml' });
                        img.src = URL.createObjectURL(svgBlob);
                    } else {
                        img.src = e.target.result;
                    }
                };
                reader.onerror = () => resolve(1);
                
                if (currentFile.type.startsWith('image/svg')) {
                    reader.readAsText(currentFile);
                } else {
                    reader.readAsDataURL(currentFile);
                }
            });
        }
        
        // å¹…ã‹ã‚‰é«˜ã•ã‚’è¨ˆç®—ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒï¼‰
        async function updateHeightFromWidth(width) {
            if (!currentFile || !elements.customHeight) return;
            const aspectRatio = await getImageAspectRatio();
            const height = Math.round(width / aspectRatio);
            elements.customHeight.value = height;
        }
        
        // é«˜ã•ã‹ã‚‰å¹…ã‚’è¨ˆç®—ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒï¼‰
        async function updateWidthFromHeight(height) {
            if (!currentFile || !elements.customWidth) return;
            const aspectRatio = await getImageAspectRatio();
            const width = Math.round(height * aspectRatio);
            elements.customWidth.value = width;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã«åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>